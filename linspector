#!/usr/bin/python2.7 -tt

__version__ = "0.2/TETRIS"

import argparse
import time
import logging
import subprocess as sp
from lib.core.job import JobInfo
from lib.core.logger import Logger
from lib.config.config import Config
from apscheduler.scheduler import Scheduler


def parseArgs():
    parser = argparse.ArgumentParser(
        description="Linspector is for monitoring the vital information of hosts, services and devices in a network.",
        epilog="linspector is not some program expecting computers to run!",
        prog="linspector")

    parser.add_argument("action", choices=["start", "stop", "restart", "attach"],
                        help="defines if linspector should beeing attached, started, stopped or restarted.")
    parser.add_argument("--version", action="version", version="%(prog)s " + str(__version__))
    parser.add_argument("-c", "--config", default="./linspector.json",
                        help="select configfile to use")
    parser.add_argument("-l", "--logfile", default="./log/linspector.log", metavar="FILE",
                        help="set logfile to use")
    parser.add_argument("-p", "--pidfile", default="./tmp/linspector.pid", metavar="FILE",
                        help="set the pidfile to use (default: /tmp/linspector.pid)")

    output = parser.add_mutually_exclusive_group()
    output.add_argument("-q", "--quiet", action="store_const", dest="loglevel", const=logging.ERROR,
                        help="output only errors")
    output.add_argument("-w", "--warning", action="store_const", dest="loglevel", const=logging.WARNING,
                        help="output warnings")
    output.add_argument("-v", "--verbose", action="store_const", dest="loglevel", const=logging.INFO,
                        help="output infos")
    output.add_argument("-d", "--debug", action="store_const", dest="loglevel", const=logging.DEBUG,
                        help="output debug infos")
    output.set_defaults(loglevel=logging.INFO)
    return parser.parse_args()


def handleJob(jobInfo):
    jobInfo.handleCall()
    print str(jobInfo)


def main():
    args = parseArgs()
    log = Logger(args.logfile, args.loglevel)

    log.i("parsed arguments")

    if args.action == "start":
        jobs = []
        scheduler = Scheduler()
        scheduler.start()
        
        log.i("starting linspector: reading config... (" + args.config + ")")
        config = Config(args.config, log)
        log.d("parsed config: " + str(config))
        for hg in config.hostgroups:
            
            for hostGroupService in hg.services:
                log.d(hostGroupService)
                jobInfo=JobInfo(hg.name, hg.members, hg.hosts, hostGroupService.service, hg.threshold, hg.parent)
                jobInfo.setLogger(log)
                for period in hostGroupService.periods:
                    log.d(period)
                    jobs.append(period.createJob(scheduler, jobInfo, handleJob))
        for job in jobs:
            log.d(str(job))
        
        while True:
            try:
                time.sleep(10)
                for job in jobs:
                    log.d(str(job))
            except:
                print "error"

    elif args.action == "stop":
        log.i("stopping linspector is currently unsupported")
    elif args.action == "restart":
        sp.call("./linspector stop")
        sp.call(
            "./linspector start --config " + args.config + " --logfile " + args.logfile + " --pidfile " + args.pidfile)
    elif args.action == "attach":
        log.i("attaching linspector is currently unsupported")

    log.close()


if __name__ == "__main__":
    main()